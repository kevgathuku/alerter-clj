[{:rule-id "rule-ai", :item {:feed-id "hn", :item-id "https://llmholdem.com/", :title "Show HN: Play poker with LLMs, or watch them play against each other", :link "https://llmholdem.com/", :published-at #inst "2026-01-10T19:27:39.000-00:00", :content "<a href=\"https://news.ycombinator.com/item?id=46569061\">Comments</a>"}, :excerpts [{:text "Show HN: Play poker with LLMs, or watch them play against each other", :matched-terms ["llm"], :source :title}]} {:rule-id "rule-ai", :item {:feed-id "hn-frontpage", :item-id "https://news.ycombinator.com/item?id=46571166", :title "Show HN: GlyphLang â€“ An AI-first programming language", :link "https://news.ycombinator.com/item?id=46571166", :published-at #inst "2026-01-10T23:46:58.000-00:00", :content "\n<p>While working on a proof of concept project, I kept hitting Claude's token limit 30-60 minutes into their 5-hour sessions. The accumulating context from the codebase was eating through tokens fast. So I built a language designed to be generated by AI rather than written by humans.<p>GlyphLang<p>GlyphLang replaces verbose keywords with symbols that tokenize more efficiently:<p><pre><code>  # Python\n  @app.route('/users/<id>')\n  def get_user(id):\n      user = db.query(\"SELECT * FROM users WHERE id = ?\", id)\n      return jsonify(user)\n\n  # GlyphLang\n  @ GET /users/:id {\n    $ user = db.query(\"SELECT * FROM users WHERE id = ?\", id)\n    > user\n  }\n\n  @ = route, $ = variable, > = return. Initial benchmarks show ~45% fewer tokens than Python, ~63% fewer than Java.\n</code></pre>\nIn practice, that means more logic fits in context, and sessions stretch longer before hitting limits. The AI maintains a broader view of your codebase throughout.<p>Before anyone asks: no, this isn't APL with extra steps. APL, Perl, and Forth are symbol-heavy but optimized for mathematical notation, human terseness, or machine efficiency. GlyphLang is specifically optimized for how modern LLMs tokenize. It's designed to be generated by AI and reviewed by humans, not the other way around. That said, it's still readable enough to be written or tweaked if the occasion requires.<p>It's still a work in progress, but it's a usable language with a bytecode compiler, JIT, LSP, VS Code extension, PostgreSQL, WebSockets, async/await, generics.<p>Docs: <a href=\"https://glyphlang.dev/docs\" rel=\"nofollow\">https://glyphlang.dev/docs</a><p>GitHub: <a href=\"https://github.com/GlyphLang/GlyphLang\" rel=\"nofollow\">https://github.com/GlyphLang/GlyphLang</a></p>\n<hr>\n<p>Comments URL: <a href=\"https://news.ycombinator.com/item?id=46571166\">https://news.ycombinator.com/item?id=46571166</a></p>\n<p>Points: 18</p>\n<p># Comments: 13</p>\n"}, :excerpts [{:text "... on a proof of concept project, I kept hitting Claude's token limit 30-60 minutes into their 5-hour...", :matched-terms ["claude"], :source :content} {:text "... is specifically optimized for how modern LLMs tokenize. It's designed to be generated by AI...", :matched-terms ["llm"], :source :content}]}]