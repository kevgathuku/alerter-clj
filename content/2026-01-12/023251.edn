[{:rule-id "rule-ai", :item {:feed-id "hn-frontpage", :item-id "https://news.ycombinator.com/item?id=46581832", :title "Show HN: What if AI agents had Zodiac personalities?", :link "https://github.com/baturyilmaz/what-if-ai-agents-had-zodiac-personalities", :published-at #inst "2026-01-11T23:49:15.000-00:00", :content "\n<p>A fun game for playing moral dilemmas with friends. I gave 12 AI agents zodiac personalities (not that I believe in them) using the same LLM with different personality prompts.</p>\n<hr>\n<p>Comments URL: <a href=\"https://news.ycombinator.com/item?id=46581832\">https://news.ycombinator.com/item?id=46581832</a></p>\n<p>Points: 15</p>\n<p># Comments: 7</p>\n"}, :excerpts [{:text "... (not that I believe in them) using the same LLM with different personality...", :matched-terms ["llm"], :source :content}]} {:rule-id "clojure", :item {:feed-id "planet-clojure", :item-id "https://tengstrand.github.io/blog/2026-01-11-tetris-playing-ai-the-polylith-way-2.html", :title "Tetris-playing AI the Polylith way - Part 2", :link "https://tengstrand.github.io/blog/2026-01-11-tetris-playing-ai-the-polylith-way-2.html", :published-at #inst "2026-01-11T23:59:59.000-00:00", :content "<div><img alt=\"Tetris AI\" src=\"https://tengstrand.github.io/blog/assets/06-tetris-playing-ai-the-polylith-way/tetris-ai.png\" style=\"width: 50%; height: auto; display: block; margin: 16px 0;\" /><p>The focus in this second part of the blog series is to showcase the benefits of getting quick feedback when working with code. We&amp;aposll do this by implementing the removal of complete rows when a Tetris piece is placed on the board.</p><p>For example, if we rotate the red piece in the image above and place it in the third position, the two bottom rows should be cleared:</p><div style=\"display: flex; margin: 20px 0;\">\n  <img alt=\"Tetris AI with piece dropped\" src=\"https://tengstrand.github.io/blog/assets/06-tetris-playing-ai-the-polylith-way/tetris-ai-placed.png\" />\n  <img alt=\"Right arrow\" src=\"https://tengstrand.github.io/blog/assets/06-tetris-playing-ai-the-polylith-way/right-arrow.png\" style=\"width: 20px; height: auto; display: block; margin: 0 10px;\" />\n  <img alt=\"Tetris AI with cleared rows\" src=\"https://tengstrand.github.io/blog/assets/06-tetris-playing-ai-the-polylith-way/tetris-ai-cleared.png\" />\n</div><p>The resulting source code from this second blog post in the series can be found here:</p><ul><li>The <a href=\"https://github.com/tengstrand/tetrisanalyzer/tree/polylith-blog-part-02/langs/clojure/tetris-polylith\">Clojure workspace</a></li><li>The <a href=\"https://github.com/tengstrand/tetrisanalyzer/tree/polylith-blog-part-02/langs/python/tetris-polylith-uv\">Python workspace</a></li></ul><h2 id=\"repl-driven-development\">REPL-driven development</h2><p>If you&amp;aposve read <a href=\"https://tengstrand.github.io/blog/05-tetris-playing-ai-the-polylith-way-1.html\">part one</a> of the blog series, you already know that all code will be implemented in both Python and Clojure, so let&amp;aposs start with the latter!</p><p>Clojure has something called a <a href=\"https://clojure.org/guides/repl/introduction\">REPL</a> (Read Eval Print Loop) that lets you write code in small steps, while getting quick feedback on whether the code works or not.</p><p>We&amp;aposll start by creating a <code>clear-rows</code> namespace in the board component:</p><pre><code class=\"language-shell\">▾ tetris-polylith\n  ▸ bases\n  ▾ components\n    ▾ board\n      ▾ src\n        clear-rows.clj\n        core.clj\n        interface.clj\n      ▸ test\n    ▸ piece\n  ▸ development\n  ▸ projects\n</code></pre><p>Where we add a board <code>row</code>:</p><pre><code class=\"language-clojure\">(ns tetrisanalyzer.board.clear-rows)\n\n(def row [1 1 1 0 1 1 1 0 1 1])\n</code></pre><p>In Clojure, we only need to compile the code that has changed. Since we&amp;aposve added a new namespace and a <code>row</code>, we need to send the entire namespace to the REPL, usually via a key-shortcut, to get it compiled to <a href=\"https://en.wikipedia.org/wiki/Java_bytecode\">Java bytecode</a>.</p><p>A complete row contains no empty cells (zeros). We can use the <a href=\"https://clojuredocs.org/clojure.core/some\">some</a> function to detect the presence of empty cells:</p><pre><code class=\"language-clojure\">(some zero? row) ;; true\n</code></pre><p>Here at least one empty cell has been found, which means the row is not complete. Let&amp;aposs also test whether we can identify a complete row:</p><pre><code class=\"language-clojure\">(ns tetrisanalyzer.board.clear-rows)\n\n(def row [1 1 1 1 1 1 1 1 1 1])\n\n(some zero? row) ;; false\n</code></pre><p>Yes, it seems to work!</p><p>Now we can create a function from the code:</p><pre><code class=\"language-clojure\">(ns tetrisanalyzer.board.clear-rows)\n\n(defn incomplete-row? [row]\n  (some zero? row))\n\n(comment\n  (incomplete-row? [1 1 1 1 1 1 1 0 1 1]) ;; true\n  (incomplete-row? [1 1 1 1 1 1 1 1 1 1]) ;; false\n  #__)\n</code></pre><p>Here I&amp;aposve added a <a href=\"https://clojuredocs.org/clojure.core/comment\">comment</a> block with a couple of calls to the function. From the development environment, we can now call one function at a time and immediately see the result, while the functions don&amp;apost run if we reload the namespace. It&amp;aposs quite common in the Clojure world to leave these comment blocks in production code so that functions can be easily called, while also serving as documentation.</p><p>We&amp;aposll clean up the comment block and instead add a <code>board</code> so we have something to test against (commas can be omitted):</p><pre><code class=\"language-clojure\">(ns tetrisanalyzer.board.clear-rows)\n\n(defn incomplete-row? [row]\n  (some zero? row))\n\n(def board [[0 0 0 0 0 0 0 0 0 0]\n            [0 0 0 0 0 0 0 0 0 0]\n            [1 1 1 1 1 1 1 1 1 1]\n            [1 1 1 1 1 1 0 0 1 1]\n            [1 0 1 1 1 1 1 1 1 1]\n            [1 1 1 1 1 1 1 1 1 1]])\n</code></pre><p>Now we can calculate the rows that should not be removed:</p><pre><code class=\"language-clojure\">(def remaining-rows (filter incomplete-row? board)) ;; ([0 0 0 0 0 0 0 0 0 0]\n                                                    ;;  [0 0 0 0 0 0 0 0 0 0]\n                                                    ;;  [1 1 1 1 1 1 0 0 1 1] \n                                                    ;;  [1 0 1 1 1 1 1 1 1 1])\n</code></pre><p>The next step is to create the two empty rows that should replace the removed ones, which we finally put in <code>empty-rows</code>:</p><pre><code class=\"language-clojure\">(def board-width (count (first board)))\n(def board-height (count board))\n(def num-cleared-rows (- board-height (count remaining-rows))) ;; 2\n(def empty-row (vec (repeat board-width 0))) ;; [0 0 0 0 0 0 0 0 0 0]\n(def empty-rows (repeat num-cleared-rows empty-row)) ;; ([0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0])\n</code></pre><p>Here&amp;aposs what the board looks like after complete rows have been removed and new empty replacement rows have been added at the beginning:</p><pre><code class=\"language-clojure\">(vec (concat empty-rows remaining-rows)) ;; [[0 0 0 0 0 0 0 0 0 0]\n                                         ;;  [0 0 0 0 0 0 0 0 0 0]\n                                         ;;  [0 0 0 0 0 0 0 0 0 0]\n                                         ;;  [0 0 0 0 0 0 0 0 0 0]\n                                         ;;  [1 1 1 1 1 1 0 0 1 1]\n                                         ;;  [1 0 1 1 1 1 1 1 1 1]]\n</code></pre><p>The <a href=\"https://clojuredocs.org/clojure.core/concat\">concat</a> function combines the two lists and creates a new list with rows, while <a href=\"https://clojuredocs.org/clojure.core/vec\">vec</a> then converts the list to a vector. Note that both <code>vec</code> and <code>concat</code> return <a href=\"https://clojure.org/reference/data_structures\">immutable data</a>, which is standard for all data structures in Clojure.</p><h3 id=\"simplify\">Simplify</h3><p>It occurred to me that we can simplify the code somewhat.</p><p>We&amp;aposll start by making <code>empty-board</code> a bit more readable by adding <code>empty-row</code>:</p><pre><code class=\"language-clojure\">(ns tetrisanalyzer.board.core)\n\n(defn empty-row [width]\n  (vec (repeat width 0)))\n\n(defn empty-board [width height]\n  (vec (repeat height (empty-row width))))\n</code></pre><p>Then we can replace:</p><pre><code class=\"language-clojure\">(def empty-row (vec (repeat board-width 0)))\n(def empty-rows (repeat num-cleared-rows empty-row))\n</code></pre><p>With:</p><pre><code class=\"language-clojure\">(def empty-rows (core/empty-board board-width num-cleared-rows))\n</code></pre><p>Now we can finally use <a href=\"https://clojuredocs.org/clojure.core/let\">let</a> to combine the different calculation steps into a function:</p><pre><code class=\"language-clojure\">(ns tetrisanalyzer.board.clear-rows\n  (:require [tetrisanalyzer.board.core :as core]))\n\n(defn incomplete-row? [row]\n  (some zero? row))\n\n(defn clear-rows [board]\n  (let [width (count (first board))\n        height (count board)\n        remaining-rows (filter incomplete-row? board)\n        num-cleared-rows (- height (count remaining-rows))\n        empty-rows (core/empty-board width num-cleared-rows)]\n    (vec (concat empty-rows remaining-rows))))\n</code></pre><p>Since we&amp;aposve already tested all the subexpressions, there&amp;aposs a good chance that the function will work as expected:</p><pre><code class=\"language-clojure\">(clear-rows board)  ;; [[0 0 0 0 0 0 0 0 0 0]\n                    ;;  [0 0 0 0 0 0 0 0 0 0]\n                    ;;  [0 0 0 0 0 0 0 0 0 0]\n                    ;;  [0 0 0 0 0 0 0 0 0 0]\n                    ;;  [1 1 1 1 1 1 0 0 1 1]\n                    ;;  [1 0 1 1 1 1 1 1 1 1]]\n</code></pre><p>And indeed, it looks correct!</p><p>We&amp;aposll finish by creating a test in the new namespace <code>clear-rows-test</code>:</p><pre><code class=\"language-shell\">▾ tetris-polylith\n  ▸ bases\n  ▾ components\n    ▸ board\n      ▸ src\n      ▾ test\n        clear-rows-test.clj\n        core-test.clj\n    ▸ piece\n  ▸ development\n  ▸ projects\n</code></pre><pre><code class=\"language-clojure\">(ns tetrisanalyzer.board.clear-rows-test\n  (:require [clojure.test :refer :all]\n            [tetrisanalyzer.board.clear-rows :as sut]))\n\n(deftest clear-two-rows\n  (is (= [[0 0 0 0 0 0 0 0 0 0]\n          [0 0 0 0 0 0 0 0 0 0]\n          [0 0 0 0 0 0 0 0 0 0]\n          [0 0 0 0 0 0 0 0 0 0]\n          [1 1 1 1 1 1 0 0 1 1]\n          [1 0 1 1 1 1 1 1 1 1]]\n         (sut/clear-rows [[0 0 0 0 0 0 0 0 0 0]\n                          [0 0 0 0 0 0 0 0 0 0]\n                          [1 1 1 1 1 1 1 1 1 1]\n                          [1 1 1 1 1 1 0 0 1 1]\n                          [1 0 1 1 1 1 1 1 1 1]\n                          [1 1 1 1 1 1 1 1 1 1]]))))\n</code></pre><p>When we run the test, it shows green and we can thus move on to the Python implementation. But first, a few words about the workflow.</p><h2 id=\"work-faster---in-small-steps\">Work faster - in small steps</h2><p>You might have noticed that we implemented the code before writing the test, and that we didn&amp;apost write the entire function in one go. Instead, we introduced one small calculation step at a time, which we only put together into a complete function at the end. This allowed us to adjust the solution as our understanding grew, and we didn&amp;apost need to keep everything in our heads. The brain has its limitations, so it&amp;aposs important that we help it along a bit!</p><p>In Clojure, only what has changed is compiled, which usually goes lightning fast. This makes you forget that it&amp;aposs actually a compiled language. You can open any file/namespace in the codebase, and execute a function, perhaps from an existing <a href=\"https://clojuredocs.org/clojure.core/comment\">comment block</a>, and immediately get a response back. Gone is the feeling that something stands between you and the code, in the form of waiting for the compiler to be satisfied.</p><p>It&amp;aposs easy to become addicted to this immediate feedback, and the feeling is very similar to working with your hands, for example, when throwing pottery:</p><figure style=\"margin: 20px 0;\">\n  <img alt=\"Pottery\" src=\"https://tengstrand.github.io/blog/assets/06-tetris-playing-ai-the-polylith-way/pottery.png\" style=\"width: 50%; height: auto; display: block;\" />\n  Me at the pottery wheel\n</figure><p>The contact with the clay resembles what you have when working in a REPL, an immediacy that lets you quickly test, adjust, and work toward an intended goal, in real time.</p><p>The absence of static typing means the compiler only needs to compile the small change that was just made and nothing else, which is a prerequisite for this fast workflow. Quality is achieved by testing the code often and in small steps, in combination with traditional testing and libraries like <a href=\"https://github.com/metosin/malli\">malli</a> and <a href=\"https://clojure.org/guides/spec\">spec</a> to validate the data.</p><p>In languages that require more extensive compilation, or lack an advanced REPL, it&amp;aposs very common to start by writing a test, both as a way to drive the code forward and to trigger a compilation of the code. In a language like Clojure, you can move forward in even smaller steps, in a fast and controlled way.</p><p>Enough about this, and let&amp;aposs switch over to Python instead!</p><h3 id=\"python\">Python</h3><p>We&amp;aposll start by trying to get as good a developer experience as possible, similar to what we have in Clojure. There are many good IDEs, but here I&amp;aposll be using <a href=\"https://www.jetbrains.com/pycharm/\">PyCharm</a>.</p><ul><li><a href=\"https://www.jetbrains.com/pycharm/download\">Install</a> PyCharm if you haven&amp;apost already.</li><li><a href=\"https://ipython.org/install/\">Install</a> IPython, preferably globally.<ul><li>IPython is an alternative to the standard <a href=\"https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop\">REPL</a> in Python.</li></ul></li><li>Configure IPython&amp;aposs <a href=\"https://ipython.readthedocs.io/en/stable/config/intro.html\">config file</a>, and add:<pre><code class=\"language-shell\">c.InteractiveShellApp.exec_lines = [\"%autoreload 2\"]\nc.InteractiveShellApp.extensions = [\"autoreload\"]\nc.TerminalInteractiveShell.confirm_exit = False\n</code></pre><ul><li>The config file is probably found here: <code>~/.ipython/profile_default/ipython_config.py</code></li></ul></li><li>Start PyCharm and go to <code>PyCharm &gt; Settings &gt; Python &gt; Console &gt; Python Console &gt; Starting script</code> and add:<pre><code class=\"language-shell\">%load_ext autoreload\n%autoreload 2\n%aimport -pydev_umd\n</code></pre><ul><li><code>%load_ext autoreload</code> loads the IPython extension <a href=\"https://ipython.org/ipython-doc/3/config/extensions/autoreload.html\">autoreload</a>, which allows modules to be reloaded automatically when files change.</li><li><code>%autoreload 2</code> enables automatic reloading of all modules (except those that are excluded)</li><li><code>%aimport -pydev_umd</code> excludes <code>pydev_umd</code> from reloading, to remove errors that would otherwise be shown in the REPL.</li><li>There may be small red markings in the configuration, but these are not real errors and can be ignored.</li></ul></li><li>Select <code>View &gt; Tool Windows &gt; Python Console</code> from the menu, which opens a <code>Python Console</code> panel in the lower part of the IDE.<ul><li>A prompt <code>In [1]</code> should now appear instead of <code>&gt;&gt;&gt;</code>, which indicates that it&amp;aposs the IPython REPL running, and not the standard REPL.</li></ul></li><li>Then I set up my keyboard shortcuts under <code>Pycharm &gt; Settings... &gt; Keymap &gt; Plugins &gt; Python Community Editor</code> to be able to send code to the REPL in the same way I&amp;aposm used to in Clojure.</li><li>I&amp;aposve also added <code>ipython&gt;=8.0.0</code> to <a href=\"https://github.com/tengstrand/tetrisanalyzer/blob/22af4864215aab356b5799d718a287d1c18841f3/langs/python/tetris-polylith-uv/pyproject.toml#L15\">pyproject.toml</a>, and ran <code>uv sync --dev</code> to load the library.</li></ul><p>Much of what&amp;aposs written here comes from <a href=\"https://davidvujic.blogspot.com/2022/08/joyful-python-with-repl.html#easy-setup\">this</a> blog post under the heading \"Easy setup\" (thanks David Vujic!).</p><p>Now it&amp;aposs high time to write some Python code, and we&amp;aposll start by creating the module <code>clear_rows.py</code>:</p><pre><code class=\"language-shell\">  ▾ components\n    ▾ tetrisanalyzer\n      ▾ board\n        __init__.py\n        clear_rows.py\n        copy.py\n      ▸ piece\n  ▸ test\n</code></pre><p>Then we add the row:</p><pre><code class=\"language-python\">row = [1, 1, 1, 0, 1, 1, 1, 0, 1, 1]\n</code></pre><p>After which we run the shortcut command to send the entire module to the REPL, so it gets loaded (output from the REPL):</p><pre><code class=\"language-python\">In [1]: runfile(&amp;apos/Users/tengstrand/source/tetrisanalyzer/langs/python/tetris-polylith-uv/components/tetrisanalyzer/board/clear_rows.py&amp;apos, wdir=&amp;apos/Users/tengstrand/source/tetrisanalyzer/langs/python/tetris-polylith-uv/components/tetrisanalyzer/board&amp;apos)\n</code></pre><p>Now we can select <code>row</code> in the editor and send it to the REPL:</p><pre><code class=\"language-python\">In [2]: row\nOut[2]: [1, 1, 1, 0, 1, 1, 1, 0, 1, 1]\n</code></pre><p>Through the REPL, we now have a convenient way to interact with the compiled code even in Python!</p><p>Let&amp;aposs translate the following line from Clojure to Python:</p><pre><code class=\"language-clojure\">(some zero? row)\n</code></pre><p>By adding the following line to <code>clear_rows.py</code>:</p><pre><code class=\"language-python\">0 in row\n</code></pre><p>Now we can select the line and send it to the REPL, which is an alternative to loading the entire module:</p><pre><code class=\"language-python\">In [3]: 0 in row\nOut[3]: True\n</code></pre><p>Then we change <code>row</code> and test again:</p><pre><code class=\"language-python\">row = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\n0 in row\n</code></pre><pre><code class=\"language-python\">In [4]: 0 in row\nOut[4]: False\n</code></pre><p>It seems to work! Time to create a function from the code, and test run it:</p><pre><code class=\"language-python\">def is_incomplete(row):\n    return 0 in row\n\nrow = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\nis_incomplete(row)\n</code></pre><pre><code class=\"language-python\">In [5]: is_incomplete(row)\nOut[5]: False\n</code></pre><p>Then I update <code>row</code> and test again:</p><pre><code class=\"language-python\">row = [1, 1, 1, 0, 1, 1, 1, 1, 1, 1]\n\nis_incomplete(row)\n</code></pre><pre><code class=\"language-python\">In [6]: is_incomplete(row)\nOut[6]: True\n</code></pre><p>It looks like it works!</p><p>Now we&amp;aposll add a <code>board</code> to the module, so we have something to test against:</p><pre><code class=\"language-python\">def is_incomplete(row):\n    return 0 in row\n\n\nboard = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n         [1, 1, 1, 1, 1, 1, 0, 0, 1, 1],\n         [1, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]\n</code></pre><p>In Clojure we can filter out incomplete rows like this:</p><pre><code class=\"language-clojure\">(filter incomplete-row? board)\n</code></pre><p>This is written most simply like this in Python:</p><pre><code class=\"language-python\">[row for row in board if is_incomplete(row)]\n</code></pre><p>The statement is a <a href=\"https://www.geeksforgeeks.org/python/python-list-comprehension/\">list comprehension</a> that creates a new list by iterating over <code>board</code> and keeping only rows where <code>is_incomplete</code> returns <code>True</code>.</p><p>Let&amp;aposs test run the expression:</p><pre><code class=\"language-python\">In [7]: [row for row in board if is_incomplete(row)]\nOut[7]: \n[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [1, 1, 1, 1, 1, 1, 0, 0, 1, 1],\n [1, 0, 1, 1, 1, 1, 1, 1, 1, 1]]\n</code></pre><p>It works!</p><p>Before <code>for</code> we have <code>row</code>, which is what we iterate over:</p><pre><code class=\"language-python\">[row for row in board if is_incomplete(row)]\n</code></pre><p>Python also allows us to do a calculation for each <code>row</code>, which can be exemplified with:</p><pre><code class=\"language-python\">[row + [9] for row in board if is_incomplete(row)]\n</code></pre><p>Which adds <code>9</code> to the end of each row:</p><pre><code class=\"language-python\">[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9],\n [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 9],\n [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 9]]\n</code></pre><p>Let&amp;aposs return to the original version and assign it to <code>remaining_rows</code>:</p><pre><code class=\"language-python\">def is_incomplete(row):\n    return 0 in row\n\nboard = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n         [1, 1, 1, 1, 1, 1, 0, 0, 1, 1],\n         [1, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]\n\nremaining_rows = [row for row in board if is_incomplete(row)]\n</code></pre><p>Before we continue, let&amp;aposs do the same refactoring of <code>empty_row</code> in <code>core.py</code> as we did in Clojure:</p><pre><code class=\"language-python\">def empty_row(width):\n    return [0] * width\n\n\ndef empty_board(width, height):\n    return [empty_row(width) for _ in range(height)]\n</code></pre><p>We continue by translating this Clojure code:</p><pre><code class=\"language-clojure\">(def width (count (first board)))\n(def height (count board))\n(def remaining-rows (filter incomplete-row? board))\n(def num-cleared-rows (- height (count remaining-rows))) ;; 2\n(def empty-rows (core/empty-board width num-cleared-rows) ;; ([0 0 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 0 0 0])\n(vec (concat empty-rows remaining-rows)) ;; [[0 0 0 0 0 0 0 0 0 0]\n                                         ;;  [0 0 0 0 0 0 0 0 0 0]\n                                         ;;  [0 0 0 0 0 0 0 0 0 0]\n                                         ;;  [0 0 0 0 0 0 0 0 0 0]\n                                         ;;  [1 1 1 1 1 1 1 0 1 1]\n                                         ;;  [1 0 1 1 1 1 1 1 1 1]]\n</code></pre><p>Till Python:</p><pre><code class=\"language-python\">width = len(board[0])\nheight = len(board)\nnum_cleared_rows = height - len(remaining_rows) # 2\nempty_rows = empty_board(width, num_cleared_rows) # [[0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0]]\nempty_rows + remaining_rows # [[0,0,0,0,0,0,0,0,0,0],\n                            #  [0,0,0,0,0,0,0,0,0,0],\n                            #  [0,0,0,0,0,0,0,0,0,0],\n                            #  [0,0,0,0,0,0,0,0,0,0],\n                            #  [1,1,1,1,1,1,0,0,1,1],\n                            #  [1,0,1,1,1,1,1,1,1,1]]\n</code></pre><p>I&amp;aposve deliberately copied the functional style from Clojure to Python, and as you can see it works excellently in Python too, but with a caveat.</p><h3 id=\"mutability\">Mutability</h3><p>At one point, part of the Clojure code looked like this:</p><pre><code class=\"language-clojure\">(def empty-row (vec (repeat board-width 0)))\n(def empty-rows (repeat num-cleared-rows empty-row)])\n</code></pre><p>Which I translated to:</p><pre><code class=\"language-python\">empty_row = [0 for _ in range(board_width)]\nempty_rows = [empty_row for _ in range(num_cleared_rows)]\n</code></pre><p>The problem with the Python code is that <code>empty_rows</code> refers to one and the same <code>empty_row</code>, and if the latter is changed, all rows in <code>empty_rows</code> change, which becomes a problem if <code>num_cleared_rows</code> is greater than one.</p><p>In the new solution, we instead create completely new rows in Python, while in Clojure we can share the same row since it&amp;aposs immutable. The fact that everything is immutable in Clojure is a big advantage when we let data flow through the system, as it prevents data from spreading uncontrollably to other parts further down in the data flow.</p><h3 id=\"putting-it-together\">Putting it together</h3><p>Let&amp;aposs put everything together into a function:</p><pre><code class=\"language-python\">from tetrisanalyzer.board.core import empty_board\n\n\ndef is_incomplete(row):\n    return 0 in row\n\n\ndef clear_rows(board):\n    width = len(board[0])\n    height = len(board)\n    remaining_rows = [row for row in board if is_incomplete(row)]\n    num_cleared_rows = height - len(remaining_rows)\n    empty_rows = empty_board(width, num_cleared_rows)\n    return empty_rows + remaining_rows\n</code></pre><p>Now we can test run it. Note that we&amp;aposve removed <code>board</code> from the source file, but the REPL still remembers it from earlier:</p><pre><code class=\"language-python\">clear_rows(board)\n</code></pre><pre><code class=\"language-python\">In [8]: clear_rows(board)\nOut[8]: \n[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [1, 1, 1, 1, 1, 1, 0, 0, 1, 1],\n [1, 0, 1, 1, 1, 1, 1, 1, 1, 1]]\n</code></pre><p>It looks correct!</p><p>Before we add a test, we need to expose the <code>clear_rows</code> function in the <code>board</code> interface, by updating <code>components/tetrisanalyzer/board/__init__.py</code> (and sending the module to the REPL):</p><pre><code class=\"language-python\">from tetrisanalyzer.board.clear_rows import clear_rows\nfrom tetrisanalyzer.board.core import empty_board, set_cell, set_piece\n\n\n__all__ = [\"empty_board\", \"set_cell\", \"set_piece\", \"clear_rows\"]\n</code></pre><p>Finally, we&amp;aposll add the test <code>test_clear_rows.py</code> to the <code>board</code> component:</p><pre><code class=\"language-shell\">  ▾ components\n    ▾ tetrisanalyzer\n      ▸ board\n      ▸ piece\n  ▾ test\n    ▾ components\n      ▾ tetrisanalyzer\n        ▾ board\n          __init__.py\n          test_clear_rows.py\n          test_core.py\n        ▸ piece\n</code></pre><pre><code class=\"language-python\">from tetrisanalyzer import board\n\n\ndef test_clear_rows():\n    input = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n             [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n             [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n             [1, 1, 1, 1, 1, 1, 0, 0, 1, 1],\n             [1, 0, 1, 1, 1, 1, 1, 1, 1, 1],\n             [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]\n    \n    expected = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                [1, 1, 1, 1, 1, 1, 0, 0, 1, 1],\n                [1, 0, 1, 1, 1, 1, 1, 1, 1, 1]]\n    \n    assert expected == board.clear_rows(input)\n</code></pre><p>Now we can run all tests with <code>uv run pytest</code>:</p><pre><code class=\"language-shell\">============================================ test session starts ============================================\nplatform darwin -- Python 3.13.11, pytest-9.0.2, pluggy-1.6.0\nrootdir: /Users/tengstrand/source/tetrisanalyzer/langs/python/tetris-polylith-uv\nconfigfile: pyproject.toml\ncollected 3 items\n\ntest/components/tetrisanalyzer/board/test_clear_rows.py .                                             [ 33%]\ntest/components/tetrisanalyzer/board/test_core.py ..                                                  [100%]\n\n============================================= 3 passed in 0.01s =============================================\n</code></pre><p>It works!</p><h3 id=\"summary\">Summary</h3><p>I&amp;aposve deliberately kept the Python code functional, partly to make it easier to compare with Clojure, but also because I like the simplicity of functional programming. We also learned that we needed to be careful when working with mutable data!</p><p>The key takeaway: working in smaller steps helps us move faster!</p><p>Happy Coding!</p></div>"}, :excerpts [{:text "...d/tetrisanalyzer/tree/polylith-blog-part-02/langs/clojure/tetris-polylith\">Clojure workspace</a></li><li>The <a...", :matched-terms ["clojure"], :source :content} {:text "... workspace</a></li></ul><h2 id=\"repl-driven-development\">REPL-driven development</h2><p>If you&amp;aposve read...", :matched-terms ["repl"], :source :content} {:text "... all code will be implemented in both Python and Clojure, so let&amp;aposs start with the latter!</p><p>Clojure has something called a <a href=\"https://clojure.org/guides/repl/introduction\">REPL</a> (Read Eval Print Loop) that lets you write...", :matched-terms ["clojure" "repl"], :source :content}]}]